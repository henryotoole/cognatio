/**
 * @file This file is loaded with every page that comes down from the server. It's responsible for setting
 * 		 up the listener for the keypresses that launch the navigator around a page.
 * @author Josh Reed
 */

// This alternative script aims to preserve my work on nav_activate. This has proven too much trouble for the
// time being.

// Use an IIFE to prevent pollution of global scope.
(() => {

	const memspace = {
		has_activated: false
	}

	import("/nav/src/nav.js").then((module)=>
	{
		// No linting here, yet.
		memspace.nav = module
		bind_keys()
	})

	/**
	 * Bind the keypress that activates the navigator 'around' this webpage.
	 */
	let bind_keys = ()=>
	{
		document.addEventListener('keydown', (e)=>
		{
			if(memspace.has_activated) return
			if(e.ctrlKey && e.altKey && e.code == "KeyC")
			{
				memspace.has_activated = true
				nav_activate()
			}
		})
	}

	/**
	 * "Activate" the navigator. This will load the navigator 'around' the existing page and the result will
	 * be the navigator pointing at this page from the same URL (e.g. no navigation occurs).
	 * 
	 * This is somewhat experimental. Obviously the safest and most sure-fire way to do this is merely to
	 * navigate to the nav app and autoload the originating page. However, I want to see if I can do this
	 * without any navigation flash.
	 * 
	 * The tactic here is to:
	 * 1. completely instantiate and load the new navigator in a non-displayed div,
	 * 2. move everything under the old body to another div
	 * 3. show the navigator div
	 * 4. hide the old body div
	 * 
	 * Any page-specific JS will continue to run silently, and the new JS will run in the viewport Iframe.
	 * Possible issues include:
	 * + css collisions
	 * + js that appends things to the body directly
	 * 
	 * In the fullness of time I may find that this is just too clunky, and I'll switch to the 'safe' method.
	 */
	let nav_activate = ()=>
	{
		// Inject links to CSS
		let nav_css = document.createElement("link")
		let font_css = document.createElement("link")
		nav_css.setAttribute("href", "/nav/assets/nav.css")
		font_css.setAttribute("href", "/nav/assets/fonts.css")
		nav_css.setAttribute("rel", "stylesheet")
		font_css.setAttribute("rel", "stylesheet")

		let vpify = (el) => {
			el.style.position = "absolute"
			el.style.top = "0px"
			el.style.left = "0px"
			el.style.width = "100vw"
			el.style.height = "100vh"
		}

		// Create navigator div
		let navroot = document.createElement("div")
		vpify(navroot)
		navroot.style.zIndex = -1
		// Create old stuff div
		let oldroot = document.createElement("div")
		oldroot.setAttribute('id', '_old_root_')
		vpify(oldroot)
		oldroot.style.zIndex = 1

		// Inject loading pane
		let loading = document.createElement("div")
		vpify(loading)
		loading.style.overflow = "hidden"
		loading.style.backgroundColor = "#f5f3ec"
		loading.style.zIndex = 2
		loading.setAttribute('id', 'reg_loading')
		navroot.append(loading)


		// Step 2: Move everything to "oldroot"
		document.body.append(oldroot)
		for(let i = 0; i < document.body.childNodes.length; i++)
		{
			let child_el = document.body.childNodes[i]
			if(!(child_el instanceof HTMLElement && child_el.getAttribute('id') == '_old_root_'))
			{
				oldroot.append(document.body.removeChild(child_el))
			}
		}

		// Step 3: Show navigator div behind other
		document.body.append(navroot)
		// Instantiate the switchyard - everything else propagates from here or events generated by the user
		let sw = new memspace.nav.RegSWNav().fab().link(navroot)
		sw.load().then(()=>
		{
			// Step 4: Pull off the tablecloth
			document.head.append(nav_css)
			document.head.append(font_css)
			oldroot.style.display = "none"
		})
		oldroot.zIndex = -1
		navroot.zIndex = ""
	}

})()