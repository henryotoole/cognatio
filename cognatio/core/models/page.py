"""
Model for the 'page', the fundamental node of the cognatio network.
"""
__author__ = "Josh Reed"

# Our code
from cognatio.core.models import Base, Friend
from cognatio import env, cognatio_config
from cognatio.util import maths
from cognatio.core.enums import PageAccessMode

# Other libs
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import String, select
from hacutils.filesys import mkdirs

# Base python
import os
from urllib.parse import urlparse

class Page(Base):
	"""The Page is the fundamental unit of a cognatio network. It represents a single node, connected to other
	pages by links / edges. Pages only have a few properties:
	+ A name that determines the file-on-disk and public-facing url
	+ Permissions (see below)

	**Permissions**
	Access to a Page can be restricted to one of three states: public, shared, and private. Public pages
	can be accessed by anyone on the web. Shared pages are only accessible by a subset of 'friends' which
	are defined in the 'friend' table on a page-py-page basis. Private pages can only be accessed by the
	'owner' user, as specified in the cognatio config.

	Write access is the sole prerogative of the cognatio network's 'owner' user. A cognatio network is a personal
	thing. It may be shared, holistically or partially, but ought to be the work of a single mind. At this time
	I have no plans to add multi-user write support. Rather; other users should build (and serve!) their own
	cognatio networks and (one day) link them with 'external' nodes (TODO).
	"""

	__tablename__ = "page"

	id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
	"""The ID, which all pages have. This is unique and autogenerated.
	"""
	name_rec: Mapped[str] = mapped_column(String(64), nullable=True)
	"""The name of the page. This is both the filename and the name for the URL. It's either provided
	as an argument to __init__ or generated as a unique hash from the ID after the ID is chosen.
	"""
	read_access_int: Mapped[int] = mapped_column()
	"""The read-access permission type. See class docstring.
	"""
	mass_cached: Mapped[int] = mapped_column()
	"""The 'mass' of a page, which is a rough measure of how developed it is. This is a cached value that results
	from scan()
	"""

	def __init__(self, read_access: PageAccessMode, name=None, mass=1):
		"""Create a record for a new Page. The name of a page is the public- and filesystem- facing descriptor
		for the page. It forms the end of the URL and must be unique relative to other Pages. If not provided,
		a short obscuring but not random hash.

		Args:
			read_access (PageAccessMode): An optional name for this new page. Default None, which means autogen. See above.
			name (str, optional): An optional name for this new page. Default None, which means autogen. See above.
			mass (int, optional): The mass of the page, Set by scan. Optional.
		"""
		# The ID doesn't exist at the time of this function being called, and name will be overwritten later
		# on first None request.
		self.name_rec = name
		self.read_access_int = read_access.value
		self.mass_cached = mass

		if self.name_rec:
			mkdirs(self.page_resource_folder_path, folder=True)

	@property
	def name(self) -> str:
		"""Get the name for this Page. This is a getter rather than merely a field so that we can autogenerate
		the name on the basis of ID later if the name was not set manually.

		Returns:
			str: The name of this page.
		"""
		if self.name_rec is None:
			# This is sort of bad practice - what if a rollback is instigated but we've already returned the
			# name for use somewhere else?
			# Well, in this specific case, it's fine because the same name will be generated next time
			# deterministically from the same ID.
			#
			# A hash length of 4 provides for 16^4 (65536) possible ID's. That's plenty.
			self.name_rec = maths.obfuscate_id(self.id, 4)
			mkdirs(self.page_resource_folder_path, folder=True)
		return self.name_rec
	
	@name.setter
	def name(self, value):
		"""A setter for the 'name' property. This will update the database name record as well as actually
		rename the file-on-disk if it exists.

		TODO
		This functionalty (e.g. renaming a Page) is complex. All other pages ought to have their links updated
		to point to this new page. This can be accomplished with some complex and not-yet-written code internally,
		but any external references to this Page will be broken unless a redirect system is setup. This is even
		trickier and would require more infrastructure.

		I'm not certain whether it's worth being able to rename a page at this time. I'm preserving the code
		I've written so far, but I'm going to make any actual rename operation raise an Exception.

		Args:
			value (str): The new name
		"""
		if value != self.name_rec:
			raise NotImplementedError("See comment block.")
		src = self.fpath
		self.name_rec = value
		dst = self.fpath

		if os.path.exists(src):
			os.rename(src, dst)
	
	@property
	def read_access(self) -> PageAccessMode:
		"""Returns:
			PageAccessMode: Enum version of the access mode.
		"""
		return PageAccessMode(self.read_access_int)

	@property
	def fpath(self) -> str:
		"""Returns:
			str: Absolute path to file on disc.
		"""
		return os.path.join(env.fpath_pages, self.name + ".html")
	
	@property
	def page_resource_folder_path(self) -> str:
		"""Returns:
			str: The absolute filesystem path for this pages 'page resource' folder.
		"""
		return os.path.join(env.fpath_pages, self.name, "resources")
	
	def get_user_read_access(self, user_id) -> bool:
		"""Get whether or not a user has access to this Page. This is a complex function that handles
		logic for all possible user-cases. It is important that this function be as optimal as possible,
		as it is frequently used to authenticate requests to NGINX.

		Args:
			user_id (int): The ID of the user to check. None is acceptable if the requesting 'user' is not
				actually logged in.

		Returns:
			bool: True if user has read access in SHARED access mode
		"""
		# Master user always gets access
		if user_id == cognatio_config["OWNER_USER_ID"]:
			return True

		# Public files always allow access.
		if self.read_access_int == PageAccessMode.PUBLIC.value:
			return True
		# Time-saving operation to reject if not public and anonymous user
		elif user_id is None:
			return False
		
		# user_id is known to be a value if we've made it this far.

		# If in PRIVATE read mode, only the owner-user can access
		if self.read_access_int == PageAccessMode.PRIVATE.value:
			return user_id == cognatio_config["OWNER_USER_ID"]
			
		# Ok, at this point this is definitely a shared page

		# If there's a 'friend' record for both the user and the page, access is allowed.
		if env.db.session.execute(select(Friend).filter_by(page_id=self.id, user_id=user_id)).first() is not None:
			return True
		
		return False

	def get_user_write_access(self, user_id) -> bool:
		"""Get whether the provided user can write. This will ONLY be true if the provided user is the config-
		defined owner.

		Args:
			user_id (int): User ID or None if anonymous

		Returns:
			bool: Whether user has write access
		"""
		if user_id is None: return False
		return user_id == cognatio_config["OWNER_USER_ID"]
	
	def set_page_content(self, content: str):
		"""Set the content for this page. Content is, literally, the text that will be sent to the browser
		when it requests a page. In many cases, content will be the text of an HTML page.

		If I ever wish to add rolling backups per-page, this will be the place.

		Args:
			content (str): The content to set to disk
		"""
		with open(self.fpath, 'w+') as ffile:
			ffile.write(content)

	@classmethod
	def get_by_name(cls, name) -> 'Page':
		"""Get a page record by its name, rather than by ID.

		Args:
			name (str): The name of the intended record.

		Returns:
			Page: The Page record instance or None if none of that name.
		"""
		return env.db.session.execute(select(Page).filter_by(name_rec=name)).scalar()
	
	@staticmethod
	def parse_url_to_name(url) -> str:
		"""Attempt to parse the name of a Page from a url. This will NOT check that the hostname / domain of the
		url matches THIS cognatio's web instance. It only checks the path.

		To be a valid page, the path following a URL must specify a file at `/page/page_name`. If the extension
		is included (e.g. `/page/page_name.html`) the extension will be stripped before the page name is returned.

		Args:
			url (str): Any URL

		Returns:
			str: The name of the resulting Page, or None if none could be parsed
		"""
		try:
			result = urlparse(url)
		except ValueError:
			return None
		
		path = result.path
		if path[0] == '/': path = path[1:]
		bits = path.split("/")

		try:
			assert len(bits) == 2
			assert bits[0] == 'page'
		except AssertionError:
			return None
		
		return bits[1].split('.')[0]